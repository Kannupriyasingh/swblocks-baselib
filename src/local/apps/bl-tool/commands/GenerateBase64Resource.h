/*
 * This file is part of the swblocks-baselib library.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifndef __APPS_BLTOOL_COMMANDS_GENERATEBASE64RESOURCE_H_
#define __APPS_BLTOOL_COMMANDS_GENERATEBASE64RESOURCE_H_

#include <apps/bl-tool/GlobalOptions.h>

#include <baselib/cmdline/CommandBase.h>

#include <baselib/core/FileEncoding.h>
#include <baselib/core/SerializationUtils.h>
#include <baselib/core/StringTemplateResolver.h>
#include <baselib/core/StringUtils.h>
#include <baselib/cmdline/CommandBase.h>

namespace
{
    const char* resourceTemplate =
        "/*\n"
        " * THIS FILE WAS GENERATED BY 'bl-tool encoding base64createresource' COMMAND\n"
        " *\n"
        " * DO NOT EDIT!\n"
        " */\n"
        "\n"
        "#ifndef __BL_RESOURCE_{{ResourceClassNameUpperCase}}_H_\n"
        "#define __BL_RESOURCE_{{ResourceClassNameUpperCase}}_H_\n"
        "\n"
        "#include <baselib/core/SerializationUtils.h>\n"
        "#include <baselib/core/BaseIncludes.h>\n"
        "\n"
        "#include <vector>\n"
        "\n"
        "#if defined( __clang__ ) || defined( __GNUC__ )\n"
        "#pragma GCC diagnostic push\n"
        "#pragma GCC diagnostic ignored \"-Woverlength-strings\"\n"
        "#endif // #if defined( __clang__ ) || defined( __GNUC__ )\n"
        "\n"
        "namespace bl\n"
        "{\n"
        "    namespace resources\n"
        "    {\n"
        "        /**\n"
        "         * @brief class {{ResourceClassName}} - A base64 encoded resource data class\n"
        "         */\n"
        "\n"
        "        template\n"
        "        <\n"
        "            typename E = void\n"
        "        >\n"
        "        class {{ResourceClassName}}T\n"
        "        {\n"
        "            BL_DECLARE_STATIC( {{ResourceClassName}}T )\n"
        "\n"
        "        private:\n"
        "\n"
        "            static const std::string g_resourceData;\n"
        "\n"
        "        public:\n"
        "\n"
        "            static auto resourceDataBase64() NOEXCEPT -> const std::string&\n"
        "            {\n"
        "                return g_resourceData;\n"
        "            }\n"
        "\n"
        "            static auto resourceDataAsString() -> std::string\n"
        "            {\n"
        "                return SerializationUtils::base64DecodeString( g_resourceData );\n"
        "            }\n"
        "\n"
        "            static auto resourceDataAsVector() -> std::vector< unsigned char >\n"
        "            {\n"
        "                return SerializationUtils::base64DecodeVector( g_resourceData );\n"
        "            }\n"
        "        };\n"
        "\n"
        "        BL_DEFINE_STATIC_CONST_STRING( {{ResourceClassName}}T, g_resourceData ) =\n"
        "{{ResourceDataBase64Encoded}}"
        "            ;\n"
        "\n"
        "        typedef {{ResourceClassName}}T<> {{ResourceClassName}};\n"
        "\n"
        "    } // resources\n"
        "\n"
        "} // bl\n"
        "\n"
        "#if defined( __clang__ ) || defined( __GNUC__ )\n"
        "#pragma GCC diagnostic pop\n"
        "#endif // #if defined( __clang__ ) || defined( __GNUC__ )\n"
        "\n"
        "#endif /* __BL_RESOURCE_{{ResourceClassNameUpperCase}}_H_ */\n";

} // __unnamed

namespace bltool
{
    namespace commands
    {
        /**
         * @brief class GenerateBase64Resource - a command to generate base64 resource data header
         */

        template
        <
            typename E = void
        >
        class GenerateBase64ResourceT : public bl::cmdline::CommandBase
        {
            BL_NO_COPY_OR_MOVE( GenerateBase64ResourceT )

        private:

            const GlobalOptions& m_globalOptions;

            typedef bl::cmdline::CommandBase                base_type;

            BL_CMDLINE_OPTION(
                m_inputFile,
                StringOption,
                "inputfile",
                "The input file to be converted to base64 resource",
                bl::cmdline::Required
                )

            BL_CMDLINE_OPTION(
                m_className,
                StringOption,
                "classname",
                "The class name which should be used to represent the base64 resource",
                bl::cmdline::Required
                )

            BL_CMDLINE_OPTION(
                m_outputFile,
                StringOption,
                "outputfile",
                "The output file to generate resource to (optional)"
                )

        public:

            GenerateBase64ResourceT(
                SAA_inout    bl::cmdline::CommandBase*    parent,
                SAA_in       const GlobalOptions&         globalOptions
                )
                :
                base_type( parent, "base64resource", "bl-tool @FULLNAME@ [options]" ),
                m_globalOptions( globalOptions )
            {
                addOption( m_inputFile );
                addOption( m_className );
                addOption( m_outputFile );

                //  |0123456789>123456789>123456789>123456789>123456789>123456789>123456789>123456789|
                setHelpMessage(
                    "Generates a base64 resource header from a file.\n"
                    "\n"
                    "Usage: @CAPTION@\n"
                    "\n"
                    "Options:\n"
                    "@OPTIONS@\n"
                    );
            }

            virtual bl::cmdline::Result execute() OVERRIDE
            {
                using namespace bl;

                const std::string encodedData = SerializationUtils::base64EncodeString(
                    encoding::readTextFile( m_inputFile.getValue() )
                    );

                const auto classNameUpperCase = str::to_upper_copy( m_className.getValue() );

                const std::size_t chunkSize = 100U;

                std::size_t pos = 0;
                bl::MessageBuffer buffer;

                while( pos < encodedData.size() )
                {
                    const std::size_t endPos = std::min< std::size_t >( encodedData.size(), pos + chunkSize );

                    buffer
                        << "            \""
                        << std::string( std::begin( encodedData ) + pos, std::begin( encodedData ) + endPos )
                        << "\"\n"
                        ;

                    pos = endPos;
                }

                const auto resourceFileTemplate = str::StringTemplateResolver::createInstance( resourceTemplate );

                std::unordered_map< std::string, std::string > variables;

                variables.emplace( "ResourceClassName", m_className.getValue() );
                variables.emplace( "ResourceClassNameUpperCase", str::to_upper_copy( m_className.getValue() ) );
                variables.emplace( "ResourceDataBase64Encoded", resolveMessage( buffer ) );

                const auto outputData = resourceFileTemplate -> resolve( variables );

                if( m_outputFile.hasValue() )
                {
                    encoding::writeTextFile(
                        m_outputFile.getValue(),
                        outputData,
                        encoding::TextFileEncoding::Ascii
                        );
                }
                else
                {
                    std::cout << outputData;
                }

                return 0;
            }
        };

        typedef GenerateBase64ResourceT<> GenerateBase64Resource;

    } // commands

} // bltool

#endif /* __APPS_BLTOOL_COMMANDS_GENERATEBASE64RESOURCE_H_ */
